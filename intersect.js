// Generated by CoffeeScript 1.6.3
(function() {
  var AABB, Hit, Point, Sweep, abs, clamp, epsilon, root, sign;

  root = typeof exports !== "undefined" && exports !== null ? exports : (this.intersect != null ? this.intersect : this.intersect = {});

  root.epsilon = epsilon = 1e-8;

  root.abs = abs = function(value) {
    if (value < 0) {
      return -value;
    } else {
      return value;
    }
  };

  root.clamp = clamp = function(value, min, max) {
    if (value < min) {
      return min;
    } else if (value > max) {
      return max;
    } else {
      return value;
    }
  };

  root.sign = sign = function(value) {
    if (value < 0) {
      return -1;
    } else {
      return 1;
    }
  };

  root.Point = Point = (function() {
    function Point(x, y) {
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      this.x = x;
      this.y = y;
    }

    Point.prototype.clone = function() {
      return new Point(this.x, this.y);
    };

    Point.prototype.normalize = function() {
      var inverseLength, length;
      length = this.x * this.x + this.y * this.y;
      if (length > 0) {
        length = Math.sqrt(length);
        inverseLength = 1.0 / length;
        this.x *= inverseLength;
        this.y *= inverseLength;
      }
      return length;
    };

    return Point;

  })();

  root.Hit = Hit = (function() {
    function Hit(collider) {
      this.collider = collider;
      this.pos = new Point();
      this.delta = new Point();
      this.normal = new Point();
    }

    return Hit;

  })();

  root.Sweep = Sweep = (function() {
    function Sweep() {
      this.hit = null;
      this.pos = new Point();
      this.time = 1;
    }

    return Sweep;

  })();

  root.AABB = AABB = (function() {
    function AABB(pos, half) {
      this.pos = pos;
      this.half = half;
    }

    AABB.prototype.intersectPoint = function(point) {
      var dx, dy, hit, px, py, sx, sy;
      dx = point.x - this.pos.x;
      px = this.half.x - abs(dx);
      if (px <= 0) {
        return null;
      }
      dy = point.y - this.pos.y;
      py = this.half.y - abs(dy);
      if (py <= 0) {
        return null;
      }
      hit = new Hit(this);
      if (px < py) {
        sx = sign(dx);
        hit.delta.x = px * sx;
        hit.normal.x = sx;
        hit.pos.x = this.pos.x + (this.half.x * sx);
        hit.pos.y = point.y;
      } else {
        sy = sign(dy);
        hit.delta.y = py * sy;
        hit.normal.y = sy;
        hit.pos.x = point.x;
        hit.pos.y = this.pos.y + (this.half.y * sy);
      }
      return hit;
    };

    AABB.prototype.intersectSegment = function(pos, delta, paddingX, paddingY) {
      var farTime, farTimeX, farTimeY, hit, nearTime, nearTimeX, nearTimeY, scaleX, scaleY, signX, signY;
      if (paddingX == null) {
        paddingX = 0;
      }
      if (paddingY == null) {
        paddingY = 0;
      }
      scaleX = 1.0 / delta.x;
      scaleY = 1.0 / delta.y;
      signX = sign(scaleX);
      signY = sign(scaleY);
      nearTimeX = (this.pos.x - signX * (this.half.x + paddingX) - pos.x) * scaleX;
      nearTimeY = (this.pos.y - signY * (this.half.y + paddingY) - pos.y) * scaleY;
      farTimeX = (this.pos.x + signX * (this.half.x + paddingX) - pos.x) * scaleX;
      farTimeY = (this.pos.y + signY * (this.half.y + paddingY) - pos.y) * scaleY;
      if (nearTimeX > farTimeY || nearTimeY > farTimeX) {
        return null;
      }
      nearTime = nearTimeX > nearTimeY ? nearTimeX : nearTimeY;
      farTime = farTimeX < farTimeY ? farTimeX : farTimeY;
      if (nearTime >= 1 || farTime <= 0) {
        return null;
      }
      hit = new Hit(this);
      if (nearTime <= 0) {
        hit.time = 0;
      } else {
        hit.time = nearTime - epsilon;
        if (hit.time < 0) {
          hit.time = 0;
        }
      }
      hit.normal.x = nearTimeX > nearTimeY ? -signX : 0;
      hit.normal.y = nearTimeX > nearTimeY ? 0 : -signY;
      hit.delta.x = hit.time * delta.x;
      hit.delta.y = hit.time * delta.y;
      hit.pos.x = pos.x + hit.delta.x;
      hit.pos.y = pos.y + hit.delta.y;
      return hit;
    };

    AABB.prototype.intersectAABB = function(box) {
      var dx, dy, hit, px, py, sx, sy;
      dx = box.pos.x - this.pos.x;
      px = (box.half.x + this.half.x) - abs(dx);
      if (px <= 0) {
        return null;
      }
      dy = box.pos.y - this.pos.y;
      py = (box.half.y + this.half.y) - abs(dy);
      if (py <= 0) {
        return null;
      }
      hit = new Hit(this);
      if (px < py) {
        sx = sign(dx);
        hit.delta.x = px * sx;
        hit.normal.x = sx;
        hit.pos.x = this.pos.x + (this.half.x * sx);
        hit.pos.y = box.pos.y;
      } else {
        sy = sign(dy);
        hit.delta.y = py * sy;
        hit.normal.y = sy;
        hit.pos.x = box.pos.x;
        hit.pos.y = this.pos.y + (this.half.y * sy);
      }
      return hit;
    };

    AABB.prototype.sweepAABB = function(box, delta) {
      var direction, sweep;
      sweep = new Sweep();
      if (delta.x === 0 && delta.y === 0) {
        sweep.pos = box.pos.clone();
        sweep.hit = this.intersectAABB(box);
        if (sweep.hit != null) {
          sweep.time = sweep.hit.time = 0;
        } else {
          sweep.time = 1;
        }
      } else {
        sweep.hit = this.intersectSegment(box.pos, delta, box.half.x, box.half.y);
        if (sweep.hit != null) {
          sweep.pos = sweep.hit.pos.clone();
          direction = delta.clone();
          direction.normalize();
          sweep.hit.pos.x += direction.x * box.half.x;
          sweep.hit.pos.y += direction.y * box.half.y;
          sweep.time = sweep.hit.time;
        } else {
          sweep.pos = new Point(box.pos.x + delta.x, box.pos.y + delta.y);
          sweep.time = 1;
        }
      }
      return sweep;
    };

    AABB.prototype.sweepInto = function(staticColliders, delta) {
      var collider, nearest, sweep, _i, _len;
      nearest = new Sweep();
      nearest.time = 1;
      nearest.pos.x = this.pos.x + delta.x;
      nearest.pos.y = this.pos.y + delta.y;
      for (_i = 0, _len = staticColliders.length; _i < _len; _i++) {
        collider = staticColliders[_i];
        sweep = collider.sweepAABB(this, delta);
        if (sweep.time < nearest.time) {
          nearest = sweep;
        }
      }
      return nearest;
    };

    return AABB;

  })();

}).call(this);
